#!/usr/bin/perl -- -*- mode: cperl -*-

=head1 NAME

rrr-server - watch a tree and continuously update indexfiles

=head1 SYNOPSIS

  rrr-server [options] principalfile

=head1 OPTIONS

=over 8

=cut

my @opt = <<'=back' =~ /B<--(\S+)>/g;

=item B<--help|h>

Prints a brief message and exists.

=item B<--verbose|v+>

More feedback.

=back

=head1 DESCRIPTION

After you have setup a tree watch it with inotify and keep it
uptodate. Depends on inotify which probably only exists on linux.

=head1 PREREQUISITE

Linux::Inotify2.

It is not declared as prerequisites of the F:R:M:Recent package
because server side handling is optional. XXX Todo: make server side
handling a separate package so we can declare Inotify2 as prereq.

=cut

use strict;
use warnings;

use File::Find qw(find);
use lib "/home/k/sources/rersyncrecent/lib";
use File::Rsync::Mirror::Recent;
use File::Spec;
use Getopt::Long;
use Pod::Usage qw(pod2usage);
use Time::HiRes qw(time);

our %Opt;
GetOptions(\%Opt,
           @opt,
          ) or pod2usage(1);

if ($Opt{help}) {
    pod2usage(0);
}

if (@ARGV != 1) {
    pod2usage(1);
}

my($principal) = @ARGV;
my $recc = File::Rsync::Mirror::Recent->new
    (local => $principal);
my($rf) = $recc->principal_recentfile;
my $rootdir = $rf->localroot;
$rootdir =~ s|/$||;
for my $req (qw(Linux::Inotify2 File::Find::Rule)) {
    eval qq{ require $req; 1 };
    if ($@) {
        die "Failing on 'require $req': $@"
    } else {
        $req->import;
    }
}

my $inotify = new Linux::Inotify2
    or die "Unable to create new inotify object: $!";

foreach my $directory ( File::Find::Rule->new->directory->in($rootdir) ) {
    $inotify->watch
        (
         $directory,
         IN_CLOSE_WRITE()
         |IN_MOVED_FROM()
         |IN_MOVED_TO()
         |IN_CREATE()
         |IN_DELETE()
         |IN_DELETE_SELF()
         |IN_MOVE_SELF()
        )
        or die "watch creation failed";
}


my $i;
my $last_aggregate_call = 0;
my $in_callback = sub {
    my $ev = shift;
    my @stringifiedmask;
    for my $watch (
                   "IN_CREATE", "IN_CLOSE_WRITE", "IN_MOVED_TO", # new
                   "IN_DELETE", "IN_MOVED_FROM",            # delete
                   "IN_DELETE_SELF", "IN_MOVE_SELF",        # self
                  ) {
        if ($ev->$watch()){
            push @stringifiedmask, $watch;
            # new directories must be added to the watches, deleted
            # directories deleted; moved directories both
        }
    }
    # warn sprintf "rootdir[$rootdir]i[%s]time[%s]ev.w.name[%s]ev.name[%s]ev.fullname[%s]mask[%s]\n", ++$i, time, $ev->w->name, $ev->name, $ev->fullname, join("|",@stringifiedmask);
    my $ignore = 0;
    if ($ev->w->name eq $rootdir) {
        my $meta = $rf->meta_data;
        my $ignore_rx = qr((?x: ^ \Q$meta->{filenameroot}\E - [0-9]*[smhdWMQYZ] \Q$meta->{serializer_suffix}\E ));
        if ($ev->name =~ $ignore_rx) {
            # warn sprintf "==> Ignoring object in rootdir looking like internal file: %s", $ev->name;
            $ignore++;
        }
    }
    unless ($ignore) {
        my $fullname = $ev->fullname;
        if (-d $fullname) {
            $inotify->watch
                (
                 $fullname,
                 IN_CLOSE_WRITE()
                 |IN_MOVED_FROM()
                 |IN_MOVED_TO()
                 |IN_CREATE()
                 |IN_DELETE()
                 |IN_DELETE_SELF()
                 |IN_MOVE_SELF()
                )
                or die "watch creation failed";
            warn "==> Newwatcher $fullname\n";
        } elsif (-f $ev->fullname) {
            if ($ev->IN_CLOSE_WRITE || $ev->IN_MOVED_TO) {
                $rf->update($ev->fullname,"new");
                warn "==> Updatefile $fullname\n";
            }
        } elsif ($ev->IN_DELETE || $ev->IN_MOVED_FROM) {
            $rf->update($ev->fullname,"delete");
            warn "==> Deletefile $fullname\n";
        } elsif ($ev->IN_DELETE_SELF || $ev->IN_MOVE_SELF) {
            $ev->w->cancel;
            warn "==> Delwatcher $fullname\n";
        } else {
            warn "==> Ignore     $fullname\n";
        }
    }
    if (time > $last_aggregate_call + $rf->interval_secs) {
        $rf->aggregate;
        $last_aggregate_call = time;
    }
};

while () {
    my @events = $inotify->read;
    unless ( @events > 0 ) {
        print "Alert: inotify read error: $!";
        last;
    }
    foreach my $event (@events) {
        $in_callback->($event);
    }
    # no sleep necessary, read is blocking
}

__END__


# Local Variables:
# mode: cperl
# coding: utf-8
# cperl-indent-level: 4
# End:
