#!/usr/bin/perl -- -*- mode: cperl -*-

=head1 NAME

rrr-dirtyupdate - add a file with an old timestamp to the dataset

=head1 SYNOPSIS

  rrr-dirtyupdate [options] file epoch

=head1 OPTIONS

=over 8

=cut

my @opt = <<'=back' =~ /B<--(\S+)>/g;

=item B<--dry-run!>

(TBD) Do not really run the command, ...

=item B<--help|h>

Prints a brief message and exists.

=item B<--verbose|v+>

More feedback.

=back

=head1 DESCRIPTION

When you later discover missing files...

=head1 BUGS

This is slow: it calls aggregate twice with force which took 2 x 10-15 seconds on PAUSE.

=cut


use strict;
use warnings;

use File::Find qw(find);
use File::Rsync::Mirror::Recent;
use Getopt::Long;
use Pod::Usage qw(pod2usage);

our %Opt;
GetOptions(\%Opt,
           @opt,
          ) or pod2usage(1);

if ($Opt{help}) {
    pod2usage(0);
}

unless (@ARGV) {
    pod2usage(1);
}

# my($file,$epoch) = @ARGV; # XXX

if ($Opt{'dry-run'}) {
    die "FIXME: not yet implemented";
}

my $rf = File::Rsync::Mirror::Recentfile->new_from_file
    (
     "/home/ftp/pub/PAUSE/authors/RECENT-1h.yaml",
    );
unless ($rf) {
    die "ALERT: Could not create an rf: $@";
}
my $sleep = 2;
warn "prove of concept for one file only. Last chance to hit ^C now to interrupt. sleeping $sleep";
sleep $sleep;
my %recfiles;
my $recent = File::Rsync::Mirror::Recent->new
    (
     local => "/home/ftp/pub/PAUSE/authors/RECENT-1h.yaml",
    );
my $recentev = $recent->news();
for my $re (@$recentev) {
    $recfiles{"/home/ftp/pub/PAUSE/authors/".$re->{path}} = 1;
}

my %diskfiles;
find({
      wanted => sub {
          my @stat = lstat $_;
          return if -l _;
          return unless -f _;
          return if delete $recfiles{$File::Find::name};
          $diskfiles{$File::Find::name} = $stat[9];
      },
      no_chdir => 1,
     },
     "/home/ftp/pub/PAUSE/authors/id"
    );

ENDLESS: while () {
    last ENDLESS unless %diskfiles;
    my @files;
 CENTOPED: for my $k (sort {$diskfiles{$a} <=> $diskfiles{$b}} keys %diskfiles) {
        push @files, $k;
        delete $diskfiles{$k};
        last CENTOPED if @files >= 263;
    }
    last ENDLESS unless @files;
    my $totalfiles = keys %diskfiles;
    my $files = @files;
    warn localtime()." ($files / $totalfiles) starting\n";
    for my $file (@files) {
        my @stat = stat $file or die "Couldn't stat '$file': $!";
        my $mtime = $stat[9];
        $rf->update($file,"new",$mtime);
        if ($file eq $files[-1]) {
            my $slt = scalar localtime $mtime;
            print localtime()." inj ts=$slt file=$file\n";
        }
    }
    warn localtime()." starting first aggregate\n";
    $rf->aggregate(force => 1);
    warn localtime()." starting second aggregate\n";
    $rf->aggregate(force => 1);
    warn localtime()." finished\n";
    sleep 45;
}

__END__


# Local Variables:
# mode: cperl
# coding: utf-8
# cperl-indent-level: 4
# End:
